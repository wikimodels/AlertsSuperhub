<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TradingView with Horizontal Lines</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
</head>

<body style="margin:0;padding:0;height:100vh;font-family:system-ui;">

  <div
    style="position:absolute;top:10px;left:10px;z-index:1000;background:rgba(255,255,255,0.95);padding:12px;border-radius:6px;box-shadow:0 2px 15px rgba(0,0,0,0.15);">
    <h1 style="margin:0 0 5px 0;font-size:20px;">BTC/USDT</h1>
    <p style="margin:0;font-size:12px;color:#666;">Lightweight Charts‚Ñ¢ ‚Ä¢ Horizontal Lines</p>
    <div id="price-legend" style="font-size:14px;font-weight:bold;margin-top:8px;">Loading...</div>
    <div id="hline-count" style="font-size:12px;color:#FF6D00;margin-top:5px;font-weight:600;">Horizontal lines: 0</div>
    <button id="clear-btn"
      style="margin-top:8px;padding:6px 12px;background:#ef5350;color:white;border:none;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600;">üßπ
      Clear All Lines</button>
    <div style="font-size:11px;color:#666;margin-top:10px;padding-top:10px;border-top:1px solid #ddd;line-height:1.5;">
      üéØ <strong>Click anywhere</strong> to add horizontal line<br>
      üóëÔ∏è <strong>Click on line</strong> to remove it<br>
      üíæ <strong>Stored in IndexedDB</strong> - persists forever!
    </div>
  </div>

  <div id="chart-container" style="width:100%;height:100%;"></div>

  <script type="module">
    // ==================== IndexedDB Manager ====================
    class HLineDatabase {
      constructor() {
        this.dbName = 'HLineStorage';
        this.storeName = 'hlines';
        this.db = null;
      }

      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, 1);

          request.onerror = () => reject(request.error);
          request.onsuccess = () => {
            this.db = request.result;
            console.log('‚úÖ IndexedDB –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
            resolve();
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
              store.createIndex('createdAt', 'createdAt', { unique: false });
              console.log('‚úÖ –°–æ–∑–¥–∞–Ω–∞ —Ç–∞–±–ª–∏—Ü–∞ HLines');
            }
          };
        });
      }

      async save(lineData) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.put(lineData);

          request.onsuccess = () => {
            console.log(`üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: ${lineData.id}`);
            resolve(lineData.id);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async delete(id) {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.delete(id);

          request.onsuccess = () => {
            console.log(`üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ: ${id}`);
            resolve();
          };
          request.onerror = () => reject(request.error);
        });
      }

      async getAll() {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();

          request.onsuccess = () => {
            console.log(`üì• –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${request.result.length} –∑–∞–ø–∏—Å–µ–π`);
            resolve(request.result);
          };
          request.onerror = () => reject(request.error);
        });
      }

      async clear() {
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.clear();

          request.onsuccess = () => {
            console.log('üßπ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –æ—á–∏—â–µ–Ω–∞');
            resolve();
          };
          request.onerror = () => reject(request.error);
        });
      }
    }

    // ==================== Chart Initialization ====================
    async function initChart() {
      const container = document.getElementById('chart-container');
      const legend = document.getElementById('price-legend');
      const hlineCount = document.getElementById('hline-count');

      if (!window.LightweightCharts) {
        console.error('‚ùå –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
        return;
      }

      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ë–î
      const db = new HLineDatabase();
      await db.init();

      const chart = LightweightCharts.createChart(container, {
        layout: { background: { color: '#ffffff' }, textColor: '#333' },
        grid: { vertLines: { color: '#f0f3fa' }, horzLines: { color: '#f0f3fa' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderColor: '#D1D4DC' },
        timeScale: { borderColor: '#D1D4DC', timeVisible: true, secondsVisible: false },
      });

      const candlestickSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
      });

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö
      function generateData() {
        const data = [];
        let time = new Date(Date.UTC(2023, 0, 1, 0, 0, 0, 0));
        let close = 20000;

        for (let i = 0; i < 2000; i++) {
          const open = close;
          const change = (Math.random() - 0.5) * 150;
          close = open + change;

          const high = Math.max(open, close) + Math.random() * 75;
          const low = Math.min(open, close) - Math.random() * 75;

          time.setHours(time.getHours() + 1);

          data.push({
            time: time.getTime() / 1000,
            open, high, low, close
          });
        }
        return data;
      }

      const data = generateData();
      candlestickSeries.setData(data);

      const horizontalLines = [];

      function generateLineId() {
        return `hline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }

      // –°–æ–∑–¥–∞—ë–º –ª–∏–Ω–∏—é –∫–∞–∫ –æ–±—ã—á–Ω—É—é series (–∫–∞–∫ VWAP)
      async function addHorizontalLine(price, savedData = null) {
        const colors = ['#2962FF', '#F23645', '#089981', '#FF6D00', '#7C4DFF'];
        const color = savedData?.color || colors[horizontalLines.length % colors.length];
        const lineId = savedData?.id || generateLineId();

        // –°–æ–∑–¥–∞—ë–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é —á–µ—Ä–µ–∑ –≤–µ—Å—å –≥—Ä–∞—Ñ–∏–∫
        const lineData = [];
        for (let i = 0; i < data.length; i++) {
          lineData.push({
            time: data[i].time,
            value: price
          });
        }

        const lineSeries = chart.addLineSeries({
          color: color,
          lineWidth: 2,
          lineStyle: LightweightCharts.LineStyle.Dashed,
          lastValueVisible: true,
          priceLineVisible: false,
          crosshairMarkerVisible: true,
        });

        lineSeries.setData(lineData);

        const lineObject = {
          id: lineId,
          price: price,
          series: lineSeries,
          color: color,
          data: lineData,
          createdAt: savedData?.createdAt || new Date().toISOString()
        };

        horizontalLines.push(lineObject);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ IndexedDB
        if (!savedData) {
          await db.save({
            id: lineObject.id,
            price: lineObject.price,
            color: lineObject.color,
            createdAt: lineObject.createdAt
          });
        }

        updateLineCount();
        console.log(`‚úÖ –õ–∏–Ω–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞ | ID: ${lineId} | Price: ${price.toFixed(2)} | Color: ${color}`);
      }

      function updateLineCount() {
        hlineCount.textContent = `Horizontal lines: ${horizontalLines.length}`;
      }

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–æ–≤ (–∫–æ–ø–∏—è –ª–æ–≥–∏–∫–∏ VWAP)
      chart.subscribeClick(async (param) => {
        if (!param || !param.point) {
          console.log("‚ö†Ô∏è –ö–ª–∏–∫ –≤–Ω–µ –≥—Ä–∞—Ñ–∏–∫–∞.");
          return;
        }

        const clickedPrice = candlestickSeries.coordinateToPrice(param.point.y);

        if (clickedPrice === null || clickedPrice === undefined) {
          console.log("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ü–µ–Ω—É –∫–ª–∏–∫–∞.");
          return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∏–∫ –Ω–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–∏–Ω–∏—é
        let clickedOnLine = false;

        for (let i = 0; i < horizontalLines.length; i++) {
          const lineObj = horizontalLines[i];
          const linePrice = lineObj.price;
          const tolerance = linePrice * 0.001; // ¬±1%

          if (Math.abs(clickedPrice - linePrice) <= tolerance) {
            const deletedId = lineObj.id;
            chart.removeSeries(lineObj.series);
            horizontalLines.splice(i, 1);

            await db.delete(deletedId);

            updateLineCount();
            console.log(`üóëÔ∏è –õ–∏–Ω–∏—è —É–¥–∞–ª–µ–Ω–∞ | ID: ${deletedId} | Price: ${linePrice.toFixed(2)} | Clicked: ${clickedPrice.toFixed(2)}`);
            clickedOnLine = true;
            return;
          }
        }

        // –ï—Å–ª–∏ –Ω–µ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ –ª–∏–Ω–∏—é, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é
        if (!clickedOnLine) {
          console.log("üéØ –î–æ–±–∞–≤–ª—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é");
          await addHorizontalLine(clickedPrice);
        }
      });

      // –õ–µ–≥–µ–Ω–¥–∞
      function updateLegend(param) {
        const validCrosshairPoint = !(
          param === undefined || param.time === undefined || param.point?.x < 0 || param.point?.y < 0
        );

        if (validCrosshairPoint) {
          const candleData = param.seriesData.get(candlestickSeries);
          if (candleData?.close) {
            const price = candleData.close.toFixed(2);
            if (candleData.open && candleData.high && candleData.low) {
              legend.innerHTML = `O: ${candleData.open.toFixed(2)}  H: ${candleData.high.toFixed(2)}  L: ${candleData.low.toFixed(2)}  C: ${price}`;
              legend.style.color = candleData.close >= candleData.open ? '#26a69a' : '#ef5350';
            } else {
              legend.innerHTML = `C: ${price}`;
            }
          }
        } else {
          const lastBar = data[data.length - 1];
          if (lastBar) {
            legend.innerHTML = `Last: ${lastBar.close.toFixed(2)}`;
            legend.style.color = lastBar.close >= lastBar.open ? '#26a69a' : '#ef5350';
          }
        }
      }

      chart.subscribeCrosshairMove(updateLegend);
      updateLegend(undefined);

      // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏
      const savedLines = await db.getAll();
      console.log(`üì• –ù–∞–π–¥–µ–Ω–æ ${savedLines.length} —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –ª–∏–Ω–∏–π`);

      for (const savedLine of savedLines) {
        await addHorizontalLine(savedLine.price, savedLine);
        console.log(`‚úÖ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ª–∏–Ω–∏—è | ID: ${savedLine.id} | Price: ${savedLine.price}`);
      }

      // –ö–Ω–æ–ø–∫–∞ –æ—á–∏—Å—Ç–∫–∏
      document.getElementById('clear-btn').addEventListener('click', async () => {
        if (!confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö?')) return;

        // –£–¥–∞–ª—è–µ–º –≤—Å–µ –ª–∏–Ω–∏–∏ —Å –≥—Ä–∞—Ñ–∏–∫–∞
        for (const lineObj of horizontalLines) {
          chart.removeSeries(lineObj.series);
        }
        horizontalLines.length = 0;

        // –û—á–∏—â–∞–µ–º –ë–î
        await db.clear();
        updateLineCount();

        console.log('üßπ –í—Å–µ –ª–∏–Ω–∏–∏ —É–¥–∞–ª–µ–Ω—ã');
      });

      // –†–µ—Å–∞–π–∑
      new ResizeObserver(entries => {
        if (entries.length === 0 || entries[0].target !== container) return;
        const newRect = entries[0].contentRect;
        chart.applyOptions({ height: newRect.height, width: newRect.width });
      }).observe(container);

      chart.timeScale().fitContent();

      // –î–æ–±–∞–≤–ª—è–µ–º –≤ window –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
      window.hlineDB = db;
      console.log('üí° –î–æ—Å—Ç—É–ø–Ω–æ: window.hlineDB.clear() - –æ—á–∏—Å—Ç–∏—Ç—å –ë–î');
    }

    window.onload = initChart;
  </script>

</body>

</html>
